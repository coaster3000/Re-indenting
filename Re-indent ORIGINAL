local readBounds = function( nMin, nMax )
	local realString = ""
	local showString = ""
	local pointer = pointer or ""
	local x, y = term.getCursorPos()

	term.setCursorPos( nMin, y)
	write( string.rep(" ", nMax - nMin + 1))
	term.setCursorPos( x - 1 < 1 and x or x - 1, y)

	term.setCursorBlink(true)
	while true do
		local event = {os.pullEvent()}
		local x, y = term.getCursorPos()

		if event[1] == "char" then
			showString = showString .. event[2]
			realString = realString .. event[2]
		elseif event[1] == "key" then
			if event[2] == keys.enter then
				print()
				return realString
			elseif event[2] == keys.backspace then
				realString = string.sub(realString, 1, realString:len() - 1)
				showString = string.sub(realString, realString:len() < nMax and -(nMax - nMin - 1) or -(realString:len()))
			end
		end
		if x == nMax then
			showString = string.sub(showString, -(nMax - nMin - 1))
		end

		term.setCursorPos( nMin, y)
		write( string.rep(" ", nMax - nMin + 1) )
		term.setCursorPos( nMin, y)
		write( showString )
	end
end

local function cPrint(text, ny) -- function made by you, modified
	if type(text) == "table" then for _, v in pairs(text) do centerPrint(v) end
	else
		local x, y = term.getCursorPos()
		local w, h = term.getSize()
		term.setCursorPos(w/2 - text:len()/2 + (#text % 2 == 0 and 1 or 0), ny or y )
		write(text)
	end
end

local width, height = term.getSize()

term.setBackgroundColour( colours.cyan )
term.clear()
term.setBackgroundColour( colours.blue )

local xMin = math.floor( width / 5 )
local xMax = math.floor( width / 5 ) * 4

local nX, nY, ntX, ntY

for i = 0, 4 do
	term.setCursorPos( xMin, math.floor( height / 3) + i + 2)
	if i == 2 then -- The lazy way
		nX, nY = term.getCursorPos()
	elseif i == 1 then
		ntX, ntY = term.getCursorPos()
	end
	write( string.rep(" ", xMax - xMin))
end

term.setTextColour( colours.white )
term.setCursorPos( xMin + 3, nY)
write(">")

term.setBackgroundColour( colours.black )
write( string.rep(" ", (xMax - 3) - (xMin + 5) ))
term.setCursorPos( xMin + 5, nY)

local nError = function( errMessage )
	local x, y = term.getCursorPos()
	
	term.setTextColour( colours.red )
	term.setBackgroundColour( colours.blue )
	cPrint( errMessage, y - 2 )
	term.setTextColour( colours.white )
	term.setBackgroundColour( colours.black )
end

local sFile
while true do
	term.setCursorPos( xMin + 5, nY )
	sFile = readBounds( xMin + 4, xMax - 4)
	if not fs.exists(sFile) or sFile == "" then
		nError("File does not exist!")
	elseif fs.isDir(sFile) then
		nError("File is a directory!")
	elseif fs.isReadOnly(sFile) then
		nError(" File is read only! ") -- Then you dont have to deal with letters if there was a error already
	else
		break
	end
end

-- Re-indenting starts
local tabWidth = 2

local onTab = {
	incr = {"if%s+.+%s+then%s*$", "for%s+.+%s+do%s*$", "while%s+.+%s+do%s*$", "repeat%s*$", "function%s+[a-zA-Z_0-9]\(.*\)%s*$"},
	decr = {"end", "until%s+.+"},
	els = {"else%s*$", "elseif%s+.+%s+then%s*$"}
}

local cPrint = function(text, ny)
	if type(text) == "table" then for _, v in pairs(text) do centerPrint(v) end
	else
		local x, y = term.getCursorPos()
		local w, h = term.getSize()
		term.setCursorPos(w/2 - text:len()/2 + (#text % 2 == 0 and 1 or 0), ny or y)
		print(text)
	end
end
local errFile = function( errMessage ) -- Temporary, changes when we work with a GUI
	local x, y = term.getCursorPos()

	term.setTextColour( colours.red )
	term.setBackgroundColour( colours.blue )
	cPrint( errMessage, y - 1 )
	
	sleep(2)
	erm.setBackgroundColour( colours.black )
	term.clear()
	term.setCursorPos( 1, 1 )
	return
end

-- Get the contents of the file
local content = {}

local handle = fs.open(sFile, "r")
for line in handle.readLine do
	content[#content + 1] = line:gsub("^%s*(.-)", "%1")
end
handle.close()

-- Map the comments & strings
local comments = {}
local inString = {}

local setComment = function( lineStart, lineEnd, charStart, charEnd)
	comments[#comments + 1] = {}
	comments[#comments].lineStart = lineStart
	comments[#comments].lineEnd = lineEnd
	comments[#comments].charStart = charStart
	comments[#comments].charEnd = charEnd
end
local setString = function( lineStart, lineEnd, charStart, charEnd)
	inString[#inString + 1] = {}
	inString[#inString].lineStart = lineStart
	inString[#inString].lineEnd = lineEnd
	inString[#inString].charStart = charStart
	inString[#inString].charEnd = charEnd
end

local bComment = false
local bString = false

for i = 1, #content do
	if string.find( content[i], "%-%-%[%[") and not bString and not bComment then
		local cStart = string.find( content[i], "%-%-%[%[")
		setComment( i, nil, cStart, nil)
		bComment = true
	elseif string.find( content[i], "%-%-%[=%[") and not bString and not bComment then
		local cStart = string.find( content[i], "%-%-%[=%[")
		setComment( i, nil, cStart, nil)
		bComment = true
	elseif string.find( content[i], "%[%[") and not bString and not bComment then
		local cStart = string.find( content[i], "%[%[")
		setString( i, nil, cStart, nil)
		bString = true
	elseif string.find( content[i], "%[=%[") and not bString and not bComment then
		local cStart = string.find( content[i], "%[=%[")
		setString( i, nil, cStart, nil)
		bString = true
	end
	if string.find( content[i], "%]%]") and bString and not bComment then
		local cStart, cEnd = string.find( content[i], "%]%]")
		inString[#inString].lineEnd = i
		inString[#inString].charEnd = cEnd
		bString = false
	elseif string.find( content[i], "%]=%]") and bString and not bComment then
		local cStart, cEnd = string.find( content[i], "%]=%]")
		inString[#inString].lineEnd = i
		inString[#inString].charEnd = cEnd
		bString = false
	end
	if string.find( content[i], "%]%]") and not bString and bComment then
		local cStart, cEnd = string.find( content[i], "%]%]")
		comments[#comments].lineEnd = i
		comments[#comments].charEnd = cEnd
		bComment = false
	elseif string.find( content[i], "%]=%]") and not bString and bComment then
		local cStart, cEnd = string.find( content[i], "%]=%]")
		comments[#comments].lineEnd = i
		comments[#comments].charEnd = cEnd
		bComment = false
	end
	if string.find( content[i], "%-%-") and not bString and not bComment then
		local cStart = string.find( content[i], "%-%-")
		setComment(i, i, cStart, -1)
	elseif string.find( content[i], "'") and not bString and not bComment then
		local cStart, cEnd = string.find( content[i], "'")
		local nextChar = string.sub( content[i], cEnd + 1, string.len(content[i]))
		local _, cEnd = string.find( nextChar, "'")
		setString( i, i, cStart, cEnd)
	elseif string.find( content[i], '"') and not bString and not bComment then
		local cStart, cEnd = string.find( content[i], '"')
		local nextChar = string.sub( content[i], cEnd + 1, string.len(content[i]))
		local _, cEnd = string.find( nextChar, '"')
		setString( i, i, cStart, cEnd)
	end
end

local isInType = function( line, charNumb )
	local mainFunc = function( tFunction )
		for _, v in pairs( tFunction ) do
			local cLineStart = v["lineStart"]
			local cLineEnd = v["lineEnd"]
			local cCharStart = v["charStart"]
			local cCharEnd = v["charEnd"]

			if line >= cLineStart and line <= cLineEnd then
				if line == cLineStart then
					return cCharStart < charNumb
				elseif line == cLineEnd then
					return cCharEnd > charNumb
				else
					return true
				end
			end
		end
	end
	if mainFunc( comments ) then return true end
	if mainFunc( inString ) then return true end
	return false
end

local new = {}
local level = 0
for k, v in pairs(content) do
	-- If we should increment level
	local incrLevel = false
	for _, incr in pairs(onTab.incr) do
		if v:find(incr) then
			local sChar = v:find(incr)
			if not isInType(k, sChar) then
				incrLevel = true
			end
		end
	end

	-- Lower level
	local decrLevel = false
	if not incrLevel then -- Preventing loop if true
		for _, decr in pairs(onTab.decr) do
			if v:find(decr) then
				local sChar = v:find(decr)
				if not isInType(k, sChar) then
					level = math.max(0, level - 1) -- Don't let the level drop below 0
					decrLevel = true
				end
			end
		end
	end

	-- Special cases
	if not decrLevel then -- Preventing the loop if true
		for _, sp in pairs(onTab.els) do
			if v:find(sp) then
				local sChar = v:find(sp)
				if not isInType(k, sChar) then
					incrLevel = true
					level = math.max(0, level - 1) -- Don't let the level drop below 0
				end
			end
		end
	end

	-- Add
	new[k] = string.rep(" ", level * tabWidth)
	
	-- Increment level
	if incrLevel then level = level + 1 end
end

fs.delete(sFile)
local file = fs.open(sFile, "a")
for k, v in pairs( content ) do
	file.writeLine( new[k] .. v )
end
file.close()

term.setBackgroundColour( colours.black )
term.clear()
term.setCursorPos(1, 1)
